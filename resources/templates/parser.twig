{% include "partials/header.twig" %}

namespace Railt\Parser\Runtime;

use Phplrt\Source\File;
use Railt\Parser\Node\Node;
use Railt\Parser\Node\Location;
use Phplrt\Parser\Rule\RuleInterface;
use Phplrt\Parser\Parser as BaseParser;
use Phplrt\Parser\Buffer\BufferInterface;
use Phplrt\Contracts\Lexer\LexerInterface;
use Phplrt\Parser\Builder\BuilderInterface;
use Phplrt\Contracts\Source\ReadableInterface;
use Railt\Parser\Extension\ExtensionInterface;
use Railt\Parser\Extension\ExtendableInterface;
use Railt\Parser\Exception\SyntaxErrorException;
use Phplrt\Parser\Exception\ParserRuntimeException;
use Phplrt\Parser\Rule\{Lexeme, Optional, Repetition, Alternation, Concatenation};

/**
 * @internal This class is generated by railt/parser, specifically by Railt\Parser\Generator\Generator
 */
final class Parser extends BaseParser implements ExtendableInterface
{
    /**
     * @var \ReflectionProperty
     */
    private \ReflectionProperty $grammar;

    /**
     * Parser constructor.
     *
     * @param LexerInterface $lexer
     * @param BuilderInterface $builder
     * @param string $root
     * @throws \Throwable
     */
    public function __construct(LexerInterface $lexer, BuilderInterface $builder, string $root)
    {
        $this->grammar = new \ReflectionProperty(parent::class, 'rules');
        $this->grammar->setAccessible(true);

        parent::__construct($lexer, $this->grammar(), [
            parent::CONFIG_AST_BUILDER  => $builder,
            parent::CONFIG_INITIAL_RULE => $root,
        ]);
    }

    /**
     * @return array|RuleInterface[]
     */
    private function grammar(): array
    {
        return [
{% for state, rule in rules %}
            {{ value(state) | raw }} => new {{ class(rule, true) }}(
{% for argument in rule.getConstructorArguments() %}
                {{ value(argument, false) | raw }},
{% endfor %}
            ),
{% endfor %}
        ];
    }

    /**
     * {@inheritDoc}
     */
    protected function next(ReadableInterface $source, BufferInterface $buffer, $state)
    {
        $from = $buffer->current()->getOffset();

        $result = parent::next($source, $buffer, $state);

        if ($result instanceof Node) {
            $result->loc = new Location($source, $from, $buffer->current()->getOffset());
        }

        return $result;
    }

    /**
     * {@inheritDoc}
     */
    public function parse($source): iterable
    {
        $source = File::new($source);

        try {
            return parent::parse($source);
        } catch (ParserRuntimeException $e) {
            throw new SyntaxErrorException($e->getMessage(), $source, $e->getToken()->getOffset());
        }
    }

    /**
     * {@inheritDoc}
     */
    public function extend(ExtensionInterface $extension): void
    {
        $rules = $this->grammar->getValue($this);

        $stream = $extension->rules();

        while ($stream->valid()) {
            [$key, $value] = [$stream->key(), $stream->current()];

            switch (true) {
                case $key === null || \is_int($key):
                    $rules[] = $value;
                    $key = \array_key_last($rules);
                    break;

                case \is_string($key):
                    $rules[$key] = $value;
                    break;

                default:
                    throw new \InvalidArgumentException('Unrecognized rule name ' . $key);
            }

            $stream->send($key);
        }

        $this->grammar->setValue($this, $rules);
    }
}
