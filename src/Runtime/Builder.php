<?php
/**
 * This file is part of Railt package and has been autogenerated.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * @see https://github.com/railt/parser/blob/No version set (parsed as 1.0.0)/LICENSE.md
 * @see https://github.com/phplrt/parser/blob/2.2.1/LICENSE.md
 * @see https://github.com/phplrt/lexer/blob/2.2.1/LICENSE.md
 */
declare(strict_types=1);

namespace Railt\Parser\Runtime;

use Phplrt\Parser\Rule\RuleInterface;
use Phplrt\Contracts\Ast\NodeInterface;
use Phplrt\Contracts\Lexer\TokenInterface;
use Phplrt\Parser\Builder\BuilderInterface;
use Phplrt\Contracts\Source\ReadableInterface;
use Railt\Parser\Extension\ExtensionInterface;
use Railt\Parser\Extension\ExtendableInterface;
use Railt\Parser\Exception\SyntaxErrorException;

/**
 * @internal This class is generated by railt/parser, specifically by Railt\Parser\Generator\Generator
 */
final class Builder implements BuilderInterface, ExtendableInterface
{
    /**
     * @var array|\Closure[]
     */
    private array $reducers = [];

    /**
     * {@inheritDoc}
     * @throws SyntaxErrorException
     * @throws \Throwable
     */
    public function build(ReadableInterface $file, RuleInterface $rule, TokenInterface $token, $state, $children)
    {
        try {
            $result = $this->reduce($state, $children);

            if (isset($this->reducers[$state])) {
                return ($this->reducers[$state])($result, $children);
            }

            return $result;
        } catch (SyntaxErrorException $e) {
            throw $e;
        } catch (\Exception $e) {
            throw new SyntaxErrorException($e->getMessage(), $file, $token->getOffset());
        }
    }

    /**
     * {@inheritDoc}
     */
    public function extend(ExtensionInterface $extension): void
    {
        foreach ($extension->reducers() as $name => $value) {
            $this->reducers[$name] = $value;
        }
    }

    /**
     * @param int|string $state
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    private function reduce($state, $children)
    {
        switch ($state) {
            case 'TypeName':
                return $this->reduceTypeName($children);
            case 'NameWithReserved':
                return $this->reduceNameWithReserved($children);
            case 'NameWithoutValues':
                return $this->reduceNameWithoutValues($children);
            case 'NameWithoutReserved':
                return $this->reduceNameWithoutReserved($children);
            case 'ListType':
                return $this->reduceListType($children);
            case 'NonNullType':
                return $this->reduceNonNullType($children);
            case 'NamedType':
                return $this->reduceNamedType($children);
            case 'BooleanValue':
                return $this->reduceBooleanValue($children);
            case 'EnumValue':
                return $this->reduceEnumValue($children);
            case 'ListValue':
                return $this->reduceListValue($children);
            case 'ListValues':
                return $this->reduceListValues($children);
            case 'NullValue':
                return $this->reduceNullValue($children);
            case 'IntValue':
                return $this->reduceIntValue($children);
            case 'FloatValue':
                return $this->reduceFloatValue($children);
            case 'ObjectValue':
                return $this->reduceObjectValue($children);
            case 'ObjectFields':
                return $this->reduceObjectFields($children);
            case 'ObjectField':
                return $this->reduceObjectField($children);
            case 'BlockStringValue':
                return $this->reduceBlockStringValue($children);
            case 'InlineStringValue':
                return $this->reduceInlineStringValue($children);
            case 'Variable':
                return $this->reduceVariable($children);
            case 'VariableName':
                return $this->reduceVariableName($children);
            case 'Description':
                return $this->reduceDescription($children);
            case 'DirectiveDefinition':
                return $this->reduceDirectiveDefinition($children);
            case 'DirectiveIsRepeatable':
                return $this->reduceDirectiveIsRepeatable($children);
            case 'DirectiveDefinitionBody':
                return $this->reduceDirectiveDefinitionBody($children);
            case 'EnumTypeDefinition':
                return $this->reduceEnumTypeDefinition($children);
            case 'EnumTypeDefinitions':
                return $this->reduceEnumTypeDefinitions($children);
            case 'EnumValueDefinition':
                return $this->reduceEnumValueDefinition($children);
            case 'FragmentDefinition':
                return $this->reduceFragmentDefinition($children);
            case 'InputObjectTypeDefinition':
                return $this->reduceInputObjectTypeDefinition($children);
            case 'InputValueDefinitions':
                return $this->reduceInputValueDefinitions($children);
            case 'InputValueDefinition':
                return $this->reduceInputValueDefinition($children);
            case 'InterfaceTypeDefinition':
                return $this->reduceInterfaceTypeDefinition($children);
            case 'ImplementsInterfaces':
                return $this->reduceImplementsInterfaces($children);
            case 'ObjectTypeDefinition':
                return $this->reduceObjectTypeDefinition($children);
            case 'FieldDefinitions':
                return $this->reduceFieldDefinitions($children);
            case 'FieldDefinition':
                return $this->reduceFieldDefinition($children);
            case 'ScalarTypeDefinition':
                return $this->reduceScalarTypeDefinition($children);
            case 'SchemaDefinition':
                return $this->reduceSchemaDefinition($children);
            case 'OperationTypeDefinitions':
                return $this->reduceOperationTypeDefinitions($children);
            case 'OperationTypeDefinition':
                return $this->reduceOperationTypeDefinition($children);
            case 'UnionTypeDefinition':
                return $this->reduceUnionTypeDefinition($children);
            case 'UnionTypeDefinitionTargets':
                return $this->reduceUnionTypeDefinitionTargets($children);
            case 'VariableDefinitions':
                return $this->reduceVariableDefinitions($children);
            case 'VariableDefinition':
                return $this->reduceVariableDefinition($children);
            case 'Arguments':
                return $this->reduceArguments($children);
            case 'Argument':
                return $this->reduceArgument($children);
            case 'RootDirectives':
                return $this->reduceRootDirectives($children);
            case 'Directives':
                return $this->reduceDirectives($children);
            case 'Directive':
                return $this->reduceDirective($children);
            case 'Field':
                return $this->reduceField($children);
            case 'FragmentSpread':
                return $this->reduceFragmentSpread($children);
            case 'InlineFragment':
                return $this->reduceInlineFragment($children);
            case 'OperationDefinition':
                return $this->reduceOperationDefinition($children);
            case 'QueryOperation':
                return $this->reduceQueryOperation($children);
            case 'MutationOperation':
                return $this->reduceMutationOperation($children);
            case 'SubscriptionOperation':
                return $this->reduceSubscriptionOperation($children);
            case 'SelectionSet':
                return $this->reduceSelectionSet($children);
            case 'Selections':
                return $this->reduceSelections($children);
            case 'EnumTypeExtension':
                return $this->reduceEnumTypeExtension($children);
            case 'InputObjectTypeExtension':
                return $this->reduceInputObjectTypeExtension($children);
            case 'InterfaceTypeExtension':
                return $this->reduceInterfaceTypeExtension($children);
            case 'ObjectTypeExtension':
                return $this->reduceObjectTypeExtension($children);
            case 'ScalarTypeExtension':
                return $this->reduceScalarTypeExtension($children);
            case 'SchemaExtension':
                return $this->reduceSchemaExtension($children);
            case 'UnionTypeExtension':
                return $this->reduceUnionTypeExtension($children);
        }

        return null;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceTypeName($children)
    {
        if ($children instanceof \Phplrt\Contracts\Lexer\TokenInterface) {
            return new \Railt\Parser\Node\NameNode($children->getValue());
        }

        return $children;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceNameWithReserved($children)
    {
        if ($children instanceof \Phplrt\Contracts\Lexer\TokenInterface) {
            return new \Railt\Parser\Node\NameNode($children->getValue());
        }

        return $children;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceNameWithoutValues($children)
    {
        if ($children instanceof \Phplrt\Contracts\Lexer\TokenInterface) {
            return new \Railt\Parser\Node\NameNode($children->getValue());
        }

        return $children;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceNameWithoutReserved($children)
    {
        return new \Railt\Parser\Node\NameNode($children->getValue());
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceListType($children)
    {
        return new \Railt\Parser\Node\Type\ListTypeNode($children[0]);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceNonNullType($children)
    {
        return new \Railt\Parser\Node\Type\NonNullTypeNode($children[0]);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceNamedType($children)
    {
        return new \Railt\Parser\Node\Type\NamedTypeNode($children[0]);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceBooleanValue($children)
    {
        return \Railt\Parser\Node\Value\BooleanValueNode::parse($children->getValue());
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceEnumValue($children)
    {
        $first = $children[0];

        switch (true) {
            case $first instanceof \Railt\Parser\Node\Value\ValueNode:
            case $first instanceof \Railt\Parser\Node\NameNode:
                return new \Railt\Parser\Node\Value\EnumValueNode($first->value);

            default:
                throw new \InvalidArgumentException('Unrecognized Enum value type: ' . \gettype($first));
        }
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceListValue($children)
    {
        return new \Railt\Parser\Node\Value\ListValueNode($children[0]);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceListValues($children)
    {
        return new \Railt\Parser\Node\Generic\ValueCollection($children);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceNullValue($children)
    {
        return new \Railt\Parser\Node\Value\NullValueNode();
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceIntValue($children)
    {
        return \Railt\Parser\Node\Value\IntValueNode::parse($children->getValue());
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceFloatValue($children)
    {
        return \Railt\Parser\Node\Value\FloatValueNode::parse($children->getValue());
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceObjectValue($children)
    {
        return new \Railt\Parser\Node\Value\ObjectValueNode($children[0]);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceObjectFields($children)
    {
        return new \Railt\Parser\Node\Generic\ObjectFieldCollection($children);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceObjectField($children)
    {
        return new \Railt\Parser\Node\Value\ObjectFieldNode($children[0], $children[1]);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceBlockStringValue($children)
    {
        return \Railt\Parser\Node\Value\StringValueNode::parse($children[0]->getValue(), true);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceInlineStringValue($children)
    {
        return \Railt\Parser\Node\Value\StringValueNode::parse($children[0]->getValue(), false);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceVariable($children)
    {
        return new \Railt\Parser\Node\Value\VariableNode($children[0]);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceVariableName($children)
    {
        return new \Railt\Parser\Node\NameNode($children[0]->getValue());
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceDescription($children)
    {
        return new \Railt\Parser\Node\Description($children ?: null);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceDirectiveDefinition($children)
    {
        $directive = new \Railt\Parser\Node\TypeSystem\Definition\DirectiveDefinitionNode(
            $children[1],
            \end($children)
        );

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Description:
                    $directive->description = $child->value;
                    break;

                case \is_bool($child):
                    $directive->repeatable = true;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\InputValueDefinitionCollection:
                    $directive->arguments = $child;
                    break;
            }
        }

        return $directive;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceDirectiveIsRepeatable($children)
    {
        return ! \is_array($children);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceDirectiveDefinitionBody($children)
    {
        return new \Railt\Parser\Node\Generic\DirectiveLocationCollection($children);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceEnumTypeDefinition($children)
    {
        $enum = new \Railt\Parser\Node\TypeSystem\Definition\EnumTypeDefinitionNode(
            $children[1]
        );

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Description:
                    $enum->description = $child->value;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $enum->directives = $child;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\EnumValueDefinitionCollection:
                    $enum->values = $child;
                    break;
            }
        }

        return $enum;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceEnumTypeDefinitions($children)
    {
        return new \Railt\Parser\Node\Generic\EnumValueDefinitionCollection($children);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceEnumValueDefinition($children)
    {
        $value = new \Railt\Parser\Node\TypeSystem\Definition\EnumValueDefinitionNode(
            $children[1]
        );

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Description:
                    $value->description = $child->value;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $value->directives = $child;
                    break;
            }
        }

        return $value;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceFragmentDefinition($children)
    {
        $fragment = new \Railt\Parser\Node\Executable\Definition\FragmentDefinitionNode(
            $children[0],
            $children[1],
            \Railt\Parser\Node\Executable\Definition\SelectionSetNode::resolve($children)
        );

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $fragment->directives = $child;
                    break;
            }
        }

        return $fragment;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceInputObjectTypeDefinition($children)
    {
        $input = new \Railt\Parser\Node\TypeSystem\Definition\InputObjectTypeDefinitionNode(
            $children[1]
        );

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Description:
                    $input->description = $child->value;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $input->directives = $child;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\InputValueDefinitionCollection:
                    $input->fields = $child;
                    break;
            }
        }

        return $input;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceInputValueDefinitions($children)
    {
        return new \Railt\Parser\Node\Generic\InputValueDefinitionCollection($children);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceInputValueDefinition($children)
    {
        $value = new \Railt\Parser\Node\TypeSystem\Definition\InputValueDefinitionNode(
            $children[1],
            $children[2]
        );

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Description:
                    $value->description = $child->value;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $value->directives = $child;
                    break;

                case $child instanceof \Railt\Parser\Node\Value\ValueNode:
                    $value->defaultValue = $child;
                    break;
            }
        }

        return $value;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceInterfaceTypeDefinition($children)
    {
        $interface = new \Railt\Parser\Node\TypeSystem\Definition\InterfaceTypeDefinitionNode(
            $children[1]
        );

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Description:
                    $interface->description = $child->value;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\FieldDefinitionCollection:
                    $interface->fields = $child;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $interface->directives = $child;
                    break;
            }
        }

        return $interface;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceImplementsInterfaces($children)
    {
        return new \Railt\Parser\Node\Generic\InterfaceTypeDefinitionCollection($children);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceObjectTypeDefinition($children)
    {
        $object = new \Railt\Parser\Node\TypeSystem\Definition\ObjectTypeDefinitionNode(
            $children[1]
        );

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Description:
                    $object->description = $child->value;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\FieldDefinitionCollection:
                    $object->fields = $child;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $object->directives = $child;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\InterfaceTypeDefinitionCollection:
                    $object->interfaces = $child;
                    break;
            }
        }

        return $object;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceFieldDefinitions($children)
    {
        return new \Railt\Parser\Node\Generic\FieldDefinitionCollection($children);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceFieldDefinition($children)
    {
        $field = new \Railt\Parser\Node\TypeSystem\Definition\FieldDefinitionNode(
            $children[1],
            \Railt\Parser\Node\Type\TypeNode::resolve($children)
        );

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $field->directives = $child;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\InputValueDefinitionCollection:
                    $field->arguments = $child;
                    break;
            }
        }

        return $field;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceScalarTypeDefinition($children)
    {
        $scalar = new \Railt\Parser\Node\TypeSystem\Definition\ScalarTypeDefinitionNode(
            $children[1]
        );

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Description:
                    $scalar->description = $child->value;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $scalar->directives = $child;
                    break;
            }
        }

        return $scalar;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceSchemaDefinition($children)
    {
        $operations = \array_filter($children, static function ($child): bool {
            return $child instanceof \Railt\Parser\Node\Generic\OperationTypeDefinitionCollection;
        });

        $schema = new \Railt\Parser\Node\TypeSystem\Definition\SchemaDefinitionNode(
            \reset($operations) ?: new \Railt\Parser\Node\Generic\OperationTypeDefinitionCollection([])
        );

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Description:
                    $schema->description = $child->value;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $schema->directives = $child;
                    break;
            }
        }

        return $schema;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceOperationTypeDefinitions($children)
    {
        return new \Railt\Parser\Node\Generic\OperationTypeDefinitionCollection($children);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceOperationTypeDefinition($children)
    {
        $operation = new \Railt\Parser\Node\TypeSystem\Definition\OperationTypeDefinitionNode(
            $children[0]->getValue(),
            $children[1]
        );

        if (isset($children[2])) {
            $operation->directives = $children[2];
        }

        return $operation;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceUnionTypeDefinition($children)
    {
        $union = new \Railt\Parser\Node\TypeSystem\Definition\UnionTypeDefinitionNode(
            $children[1]
        );

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Description:
                    $union->description = $child->value;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $union->directives = $child;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\TypeDefinitionCollection:
                    $union->types = $child;
                    break;
            }
        }

        return $union;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceUnionTypeDefinitionTargets($children)
    {
        return new \Railt\Parser\Node\Generic\TypeDefinitionCollection($children);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceVariableDefinitions($children)
    {
        return new \Railt\Parser\Node\Generic\VariableDefinitionCollection($children);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceVariableDefinition($children)
    {
        $variable = new \Railt\Parser\Node\Executable\Definition\VariableDefinitionNode(
            \array_shift($children),
            \array_shift($children)
        );

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $variable->directives = $child;
                    break;

                case $child instanceof \Railt\Parser\Node\Value\ValueNode:
                    $variable->defaultValue = $child;
                    break;
            }
        }

        return $variable;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceArguments($children)
    {
        return new \Railt\Parser\Node\Generic\ArgumentCollection($children);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceArgument($children)
    {
        return new \Railt\Parser\Node\Executable\Definition\ArgumentNode(...$children);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceRootDirectives($children)
    {
        return new \Railt\Parser\Node\Generic\RootDirectiveCollection($children);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceDirectives($children)
    {
        return new \Railt\Parser\Node\Generic\DirectiveCollection($children);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceDirective($children)
    {
        $directive = new \Railt\Parser\Node\Executable\Definition\DirectiveNode($children[0]);

        if (isset($children[1])) {
            $directive->arguments = $children[1];
        }

        return $directive;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceField($children)
    {
        [$alias, $name] = isset($children[1]) && $children[1] instanceof \Railt\Parser\Node\NameNode
            ? $children
            : [null, $children[0]];

        $field = new \Railt\Parser\Node\Executable\Definition\FieldNode($name, $alias);

         foreach ($children as $child) {
             switch (true) {
                 case $child instanceof \Railt\Parser\Node\Generic\ArgumentCollection:
                     $field->arguments = $child;
                     break;
                 case $child instanceof \Railt\Parser\Node\Executable\Definition\SelectionSetNode:
                     $field->selectionSet = $child;
                     break;
             }
         }

        return $field;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceFragmentSpread($children)
    {
        $fragment = new \Railt\Parser\Node\Executable\Definition\FragmentSpreadNode($children[0]);

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $fragment->directives = $child;
                    break;
            }
        }

        return $fragment;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceInlineFragment($children)
    {
        $fragment = new \Railt\Parser\Node\Executable\Definition\InlineFragmentNode(\end($children));

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $fragment->directives = $child;
                    break;

                case $child instanceof \Railt\Parser\Node\Type\NamedTypeNode:
                    $fragment->typeCondition = $child;
                    break;
            }
        }

        return $fragment;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceOperationDefinition($children)
    {
        $operation = \array_shift($children);

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\NameNode:
                    $operation->name = $child;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\VariableDefinitionCollection:
                    $operation->variables = $child;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $operation->directives = $child;
                    break;
            }
        }

        return $operation;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceQueryOperation($children)
    {
        return [new \Railt\Parser\Node\Executable\Definition\OperationDefinitionNode('query', \array_pop($children)), ...$children];
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceMutationOperation($children)
    {
        return [new \Railt\Parser\Node\Executable\Definition\OperationDefinitionNode('mutation', \array_pop($children)), ...$children];
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceSubscriptionOperation($children)
    {
        return [new \Railt\Parser\Node\Executable\Definition\OperationDefinitionNode('subscription', \array_pop($children)), $children];
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceSelectionSet($children)
    {
        return new \Railt\Parser\Node\Executable\Definition\SelectionSetNode(\reset($children));
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceSelections($children)
    {
        return new \Railt\Parser\Node\Generic\SelectionCollection($children);
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceEnumTypeExtension($children)
    {
        $enum = new \Railt\Parser\Node\TypeSystem\Extension\EnumTypeExtensionNode(
            $children[1]
        );

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Description:
                    $enum->description = $child->value;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $enum->directives = $child;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\EnumValueDefinitionCollection:
                    $enum->values = $child;
                    break;
            }
        }

        return $enum;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceInputObjectTypeExtension($children)
    {
        $input = new \Railt\Parser\Node\TypeSystem\Extension\InputObjectTypeExtensionNode(
            $children[1]
        );

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Description:
                    $input->description = $child->value;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $input->directives = $child;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\InputValueDefinitionCollection:
                    $input->fields = $child;
                    break;
            }
        }

        return $input;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceInterfaceTypeExtension($children)
    {
        $interface = new \Railt\Parser\Node\TypeSystem\Extension\InterfaceTypeExtensionNode(
            $children[1]
        );

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Description:
                    $interface->description = $child->value;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\FieldDefinitionCollection:
                    $interface->fields = $child;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $interface->directives = $child;
                    break;
            }
        }

        return $interface;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceObjectTypeExtension($children)
    {
        $object = new \Railt\Parser\Node\TypeSystem\Extension\ObjectTypeExtensionNode(
            $children[1]
        );

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Description:
                    $object->description = $child->value;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\FieldDefinitionCollection:
                    $object->fields = $child;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $object->directives = $child;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\InterfaceTypeDefinitionCollection:
                    $object->interfaces = $child;
                    break;
            }
        }

        return $object;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceScalarTypeExtension($children)
    {
        $scalar = new \Railt\Parser\Node\TypeSystem\Extension\ScalarTypeExtensionNode(
            $children[1]
        );

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Description:
                    $scalar->description = $child->value;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $scalar->directives = $child;
                    break;
            }
        }

        return $scalar;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceSchemaExtension($children)
    {
        $schema = new \Railt\Parser\Node\TypeSystem\Extension\SchemaExtensionNode();

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Description:
                    $schema->description = $child->value;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $schema->directives = $child;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\OperationTypeDefinitionCollection:
                    $schema->operationTypes = $child;
                    break;
            }
        }

        return $schema;
    }

    /**
     * @param NodeInterface|NodeInterface[]|TokenInterface|TokenInterface[] $children
     * @return NodeInterface|mixed
     * @throws \Throwable
     */
    protected function reduceUnionTypeExtension($children)
    {
        $union = new \Railt\Parser\Node\TypeSystem\Extension\UnionTypeExtensionNode(
            $children[1]
        );

        foreach ($children as $child) {
            switch (true) {
                case $child instanceof \Railt\Parser\Node\Description:
                    $union->description = $child->value;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\DirectiveCollection:
                    $union->directives = $child;
                    break;

                case $child instanceof \Railt\Parser\Node\Generic\TypeDefinitionCollection:
                    $union->types = $child;
                    break;
            }
        }

        return $union;
    }

}

